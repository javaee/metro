<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;16.&nbsp;Data Contracts</title><link rel="stylesheet" href="style/documentation.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Metro User Guide"><link rel="up" href="index.html" title="Metro User Guide"><link rel="prev" href="ch15.html" title="Chapter&nbsp;15.&nbsp;Accessing Metro Services Using WCF Clients"><link rel="next" href="ch17.html" title="Chapter&nbsp;17.&nbsp;Modular Databinding"><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2105126-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;16.&nbsp;Data Contracts</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch15.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch17.html">Next</a></td></tr></table><hr></div><small xmlns:fo="http://www.w3.org/1999/XSL/Format" class="small">Links: <a href="index.html">Table of Contents</a> | <a href="user-guide.html">Single HTML</a> | <a href="user-guide.pdf">Single PDF</a></small><div lang="en" class="chapter" title="Chapter&nbsp;16.&nbsp;Data Contracts"><div class="titlepage"><div><div><h2 class="title"><a name="ahigx"></a>Chapter&nbsp;16.&nbsp;Data Contracts</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="ch16.html#ahigy">16.1. Web Service - Start from Java</a></span></dt><dd><dl><dt><span class="section"><a href="ch16.html#ahigz">16.1.1. Data Types</a></span></dt><dt><span class="section"><a href="ch16.html#ahihn">16.1.2. Fields and Properties</a></span></dt><dt><span class="section"><a href="ch16.html#ahihr">16.1.3. Java Classes</a></span></dt><dt><span class="section"><a href="ch16.html#ahihv">16.1.4. Open Content</a></span></dt><dt><span class="section"><a href="ch16.html#ahihw">16.1.5. Enum Type</a></span></dt><dt><span class="section"><a href="ch16.html#ahihx">16.1.6. Package-level Annotations</a></span></dt></dl></dd><dt><span class="section"><a href="ch16.html#ahiia">16.2. Web Service - Start from WSDL</a></span></dt><dt><span class="section"><a href="ch16.html#ahiic">16.3. Customizations for WCF Service WSDL</a></span></dt><dd><dl><dt><span class="section"><a href="ch16.html#ahiid">16.3.1. generateElementProperty Attribute</a></span></dt></dl></dd><dt><span class="section"><a href="ch16.html#ahiii">16.4. Developing a Microsoft .NET Client</a></span></dt><dt><span class="section"><a href="ch16.html#ahiij">16.5. BP 1.1 Conformance</a></span></dt></dl></div><div class="section" title="16.1.&nbsp;Web Service - Start from Java"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ahigy"></a>16.1.&nbsp;Web Service - Start from Java</h2></div></div></div><p>This section provides guidelines for designing an XML schema
        exported by a Java web service designed starting from Java. JAXB 2.0
        provides a rich set of annotations and types for mapping Java classes
        to different XML Schema constructs. The guidelines provide guidance on
        using JAXB 2.0 annotations and types so that developer friendly
        bindings may be generated by XML serialization mechanisms (svcutil) on
        WCF client.</p><p>Not all JAXB 2.0 annotations are included here; not all are
        relevant from an interoperability standpoint. For example, the
        annotation <code class="code">@XmlAccessorType</code> provides control over default
        serialization of fields and properties in a Java class but otherwise
        has no effect on the on-the-wire XML representation or the XML schema
        generated from a Java class. Select JAXB 2.0 annotations are therefore
        not included here in the guidance.</p><p>The guidance includes several examples, which use the following
        conventions:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The prefix <code class="code">xs:</code> is used to represent XML
                Schema namespace.</p></li><li class="listitem"><p>JAXB 2.0 annotations are defined in
                <code class="code">javax.xml.bind.annotation</code> package but, for
                brevity, the package name has been omitted.</p></li></ul></div><div class="section" title="16.1.1.&nbsp;Data Types"><div class="titlepage"><div><div><h3 class="title"><a name="ahigz"></a>16.1.1.&nbsp;Data Types</h3></div></div></div><p>This section covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="xref" href="ch16.html#ahiha" title="16.1.1.1.&nbsp;Primitives and Wrappers">Primitives and Wrappers</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihb" title="16.1.1.2.&nbsp;BigDecimal Type">BigDecimal Type</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihc" title="16.1.1.3.&nbsp;java.net.URI Type">java.net.URI Type</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihd" title="16.1.1.4.&nbsp;Duration">Duration</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihe" title="16.1.1.5.&nbsp;Binary Types">Binary Types</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihf" title="16.1.1.6.&nbsp;XMLGregorianCalendar Type">XMLGregorianCalendar Type</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihg" title="16.1.1.7.&nbsp;UUID Type">UUID Type</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihh" title="16.1.1.8.&nbsp;Typed Variables">Typed Variables</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihi" title="16.1.1.9.&nbsp;Collections Types">Collections Types</a></p></li><li class="listitem"><p><a class="xref" href="ch16.html#ahihm" title="16.1.1.10.&nbsp;Array Types">Array Types</a></p></li></ul></div><div class="section" title="16.1.1.1.&nbsp;Primitives and Wrappers"><div class="titlepage"><div><div><h4 class="title"><a name="ahiha"></a>16.1.1.1.&nbsp;Primitives and Wrappers</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> Java primitive and
                wrapper classes map to slightly different XML schema
                representations. Therefore, .NET bindings will vary
                accordingly.</p><div class="example"><a name="d0e14131"></a><p class="title"><b>Example&nbsp;16.1.&nbsp;A Java primitive type and its corresponding wrapper
                        class</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class StockItem{
    public Double wholeSalePrice;
    public double retailPrice;
}

//--Schema fragment
&lt;xs:complexType name="stockItem"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="wholeSalePrice" type="xs:double" minOccurs="0"/&gt;
        &lt;xs:element name="retailPrice" type="xs:double"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET C# auto generated code from schema
public partial class stockItem
{
    private double wholeSalePrice;
    private bool wholeSalePriceFieldSpecified;
    private double retailPrice;

    public double wholeSalePrice
    {
        get{ return this.wholeSalePrice;}
        set{this.wholeSalePrice=value}
    }

    public bool wholeSalePriceSpecified
    {
        get{ return this.wholeSalePriceFieldSpecified;}
        set{this.wholeSalePriceFieldSpecified=value}
    }

    public double retailPrice
    {
        get{ return this.retailPrice;}
        set{this.retailPrice=value}
    }
}

//-- C# code fragment
stockItem s = new stockItem();
s.wholeSalePrice = Double.parse("198.92");
s.wholeSalePriceSpecified = true;
s.retailPrice = Double.parse("300.25");</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.2.&nbsp;BigDecimal Type"><div class="titlepage"><div><div><h4 class="title"><a name="ahihb"></a>16.1.1.2.&nbsp;BigDecimal Type</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> Limit decimal values to
                the range and precision of .NET's
                <code class="code">System.decimal</code>.</p><p><code class="code">java.math.BigDecimal</code> maps to
                <code class="code">xs:decimal</code>. .NET maps <code class="code">xs:decimal</code> to
                <code class="code">System.decimal</code>. These two data types support
                different range and precision.
                <code class="code">java.math.BigDecimal</code> supports arbitrary
                precision. <code class="code">System.decimal</code> does not. For
                interoperability use only values within the range and
                precision of <code class="code">System.decimal</code>. (See
                <code class="code">System.decimal.Minvalue</code> and
                <code class="code">System.decimal.Maxvalue</code>.) Any values outside of
                this range require a customized .NET client.</p><div class="example"><a name="d0e14174"></a><p class="title"><b>Example&nbsp;16.2.&nbsp;<code class="code">BigDecimal</code> usage</b></p><div class="example-contents"><pre class="programlisting">//--- Java code fragment
public class RetBigDecimal {
    private BigDecimal arg0;

    public BigDecimal getArg0() { return this.arg0; }
    public void setArg0(BigDecimal arg0) { this.arg0 = arg0; }
}

//--- Schema fragment
&lt;xs:complexType name="retBigDecimal"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="arg0" type="xs:decimal" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//--- .NET auto generated code from schema
public partial class retBigDecimal{
    private decimal arg0Field;
    private bool arg0FieldSpecified;

    public decimal arg0 {
        get { return this.arg0Field;}
        set { this.arg0Field = value;}
    }

    public bool arg0Specified {
        get { return this.arg0FieldSpecified;}
        set { this.arg0FieldSpecified = value;}
    }
}

//--- C# code fragment
System.CultureInfo engCulture = new System.CultureInfo("en-US");
retBigDecimal bd = new retBigDecimal();
bd.arg0 = System.decimal.MinValue;

retBigDecimal negBd = new retBigDecimal();
negBd = System.decimal.Parse("-0.0", engCulture);</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.3.&nbsp;java.net.URI Type"><div class="titlepage"><div><div><h4 class="title"><a name="ahihc"></a>16.1.1.3.&nbsp;java.net.URI Type</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> Use the
                <code class="code">@XmlSchemaType</code> annotation for a strongly typed
                binding to a .NET client generated with the
                <code class="code">DataContractSerializer</code>.</p><p><code class="code">java.net.URI</code> maps to
                <code class="code">xs:string</code>. .NET maps <code class="code">xs:string</code> to
                <code class="code">System.string</code>. Annotation
                <code class="code">@XmlSchemaType</code> can be used to define a more
                strongly typed binding to a .NET client generated with the
                <code class="code">DataContractSerializer</code>.
                <code class="code">@XmlSchemaType</code> can be used to map
                <code class="code">java.net.URI</code> to <code class="code">xs:anyURI</code>. .NET's
                <code class="code">DataContractSerializer</code> and
                <code class="code">XmlSerializer</code> bind <code class="code">xs:anyURI</code>
                differently:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">DataContractSerializer</code> binds
                        <code class="code">xs:anyURI</code> to .NET type
                        <code class="code">System.Uri</code>.</p></li><li class="listitem"><p><code class="code">XmlSerializer</code> binds
                        <code class="code">xs:anyURI</code> to .NET type
                        <code class="code">System.string</code>.</p></li></ul></div><p>Thus, the above technique only works if the WSDL is
                processed using <code class="code">DataContractSerializer</code>.</p><div class="example"><a name="d0e14259"></a><p class="title"><b>Example&nbsp;16.3.&nbsp;<code class="code">@XmlSchemaType</code> and
                    <code class="code">DataContractSerializer</code></b></p><div class="example-contents"><pre class="programlisting">// Java code fragment
public class PurchaseOrder
{
    @XmlSchemaType(name="anyURI")
     public java.net.URI uri;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="uri" type="xs:anyURI" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//--- .NET auto generated code from schema
//--- Using svcutil.exe /serializer:DataContractSerializer &lt;wsdl file&gt;
public partial class purchaseOrder : object,
        System.Runtime.Serialization.IExtensibleDataObject
{

    private System.Uri uriField;

    //-- ..... other generated code ........
    public System.Uri uri
    {
        get { return this.uriField; }
        set { this.uriField = value; }
    }
}

//--- C# code fragment
purchaseOrder tmpU = new purchaseOrder()
tmpU.uri = new System.Uri("../Hello", System.UriKind.Relative);</pre></div></div><br class="example-break"><div class="example"><a name="d0e14268"></a><p class="title"><b>Example&nbsp;16.4.&nbsp;<code class="code">@XmlSchemaType</code> and
                    <code class="code">XmlSerializer</code></b></p><div class="example-contents"><pre class="programlisting">// Java code fragment
public class PurchaseOrder
{
    @XmlSchemaType(name="anyURI")
    public java.net.URI uri;
}

//--- .NET auto generated code from schema
//--- Using svcutil.exe /serializer:XmlSerializer &lt;wsdl file&gt;
public partial class purchaseOrder
{
    private string uriField;
    public string uri
    {
        get { return this.uriField; }
        set { this.uriField = value; }
    }
}

//--- C# code fragment
purchaseOrder tmpU = new purchaseOrder()
tmpU.uri = "mailto:mailto:mduerst@ifi.unizh.ch";</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.4.&nbsp;Duration"><div class="titlepage"><div><div><h4 class="title"><a name="ahihd"></a>16.1.1.4.&nbsp;Duration</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> Use .NET's
                <code class="code">System.Xml.XmlConvert</code> to generate a lexical
                representation of <code class="code">xs:duration</code> when the binding is
                to a type of <code class="code">System.string</code>.</p><p><code class="code">javax.xml.datatype.Duration</code> maps to
                <code class="code">xs:duration</code>. .NET maps <code class="code">xs:duration</code>
                to a different datatype for
                <code class="code">DataContractSerializer</code> and
                <code class="code">XmlSerializer</code>.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">DataContractSerializer</code> binds
                        <code class="code">xs:duration</code> to .NET
                        <code class="code">System.TimeSpan</code>.</p></li><li class="listitem"><p><code class="code">XmlSerializer</code> binds
                        <code class="code">xs:duration</code> to .NET
                        <code class="code">System.string</code>.</p></li></ul></div><p>When <code class="code">xs:duration</code> is bound to .NET
                <code class="code">System.string</code>, the string value must be a lexical
                representation for <code class="code">xs:duration</code>. .NET provides
                utility <code class="code">System.Xml.XmlConvert</code> for this
                purpose.</p><div class="example"><a name="d0e14346"></a><p class="title"><b>Example&nbsp;16.5.&nbsp;Mapping <code class="code">xs:duration</code> using
                    <code class="code">DataContactSerializer</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class PurchaseReport {
     public javax.xml.datatype.Duration period;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseReport"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="period" type="xs:duration" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
//-- Using svcutil.exe /serializer:DataContractSerializer &lt;wsdl file&gt;
public partial class purchaseReport: object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private System.TimeSpan periodField;
    //-- ..... other generated code ........
    public System.TimeSpan period
    {
        get { return this.periodField; }
        set { this.periodField = value; }
    }
}

//-- C# code fragment
purchaseReport tmpR = new purchaseReport();
tmpR.period = new System.TimeSpan.MaxValue;</pre></div></div><br class="example-break"><div class="example"><a name="d0e14356"></a><p class="title"><b>Example&nbsp;16.6.&nbsp;Mapping <code class="code">xs:duration</code> using
                    <code class="code">XmlSerializer</code></b></p><div class="example-contents"><pre class="programlisting">//-- .NET auto generated code from schema
//-- Using svcutil.exe /serializer:XmlSerializer &lt;wsdl file&gt;
public partial class purchaseReport
{
    private string periodField;
    public string period
    {
        get { return this.periodField; }
        set { this.periodField = value; }
    }
}

//-- C# code fragment
purchaseReport tmpR = new purchaseReport();
tmpR.period = System.Xml.XmlConvert.ToString(new System.TimeSpan(23, 0,0));</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.5.&nbsp;Binary Types"><div class="titlepage"><div><div><h4 class="title"><a name="ahihe"></a>16.1.1.5.&nbsp;Binary Types</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span>
                <code class="code">java.awt.Image</code>,
                <code class="code">javax.xml.transform.Source</code>, and
                <code class="code">javax.activation.DataHandler</code> map to
                <code class="code">xs:base64Binary</code>. .NET maps
                <code class="code">xs:base64Binary</code> to <code class="code">byte[]</code>.</p><p>JAXB 2.0 provides the annotation
                <code class="code">@XmlMimeType</code>, which supports specifying the
                content type, but .NET ignores this information.</p><div class="example"><a name="d0e14396"></a><p class="title"><b>Example&nbsp;16.7.&nbsp;Mapping <code class="code">java.awt.Image</code>
                    <span class="emphasis"><em>without</em></span>
                    <code class="code">@XmlMimeType</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class Claim {
    public java.awt.Image photo;
}

//-- Schema fragment
&lt;xs:complexType name="claim"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="photo" type="xs:base64Binary" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
public partial class claim : object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private byte[] photoField;
    //-- ..... other generated code .......
    public byte[] photo
    {
        get { return this.photoField; }
        set { this.photoField = value; }
    }
}

//-- C# code fragment
try
{
    claim tmpC = new claim();

    System.IO.FileStream f = new System.IO.FileStream(
        "C:\\icons\\circleIcon.gif", System.IO.FileMode.Open);
    int cnt = (int)f.Length;
    tmpC.photo = new byte[cnt];
    int rCnt = f.Read(tmpC.photo, 0, cnt);

}
catch (Exception e)
{
    Console.WriteLine(e.ToString());
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e14409"></a><p class="title"><b>Example&nbsp;16.8.&nbsp;Mapping <code class="code">java.awt.Image</code>
                    <span class="emphasis"><em>with</em></span>
                    <code class="code">@XmlMimeType</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class Claim {
    @XmlMimeType("image/gif")
    public java.awt.Image photo;
}

//-- Schema fragment
&lt;xs:complexType name="claim"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="photo" ns1:expectedContentTypes="image/gif"
                    type="xs:base64Binary" minOccurs="0"
                    xmlns:ns1="http://www.w3.org/2005/05/xmlmime"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- Using the @XmlMimeType annotation doesn't change .NET
//--auto generated code
public partial class claim : object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private byte[] photoField;
    //-- ..... other generated code .......
    public byte[] photo
    {
        get { return this.photoField; }
        set { this.photoField = value; }
    }
}

//-- This code is unchanged by the different schema
//-- C# code fragment
try
{
    claim tmpC = new claim();

    System.IO.FileStream f = new System.IO.FileStream(
        "C:\\icons\\circleIcon.gif", System.IO.FileMode.Open);
    int cnt = (int)f.Length;
    tmpC.photo = new byte[cnt];
    int rCnt = f.Read(tmpC.photo, 0, cnt);
}
catch (Exception e)
{
    Console.WriteLine(e.ToString());
}</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.6.&nbsp;XMLGregorianCalendar Type"><div class="titlepage"><div><div><h4 class="title"><a name="ahihf"></a>16.1.1.6.&nbsp;XMLGregorianCalendar Type</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> Use
                <code class="code">java.xml.datatype.XMLGregorianCalendar</code> instead of
                <code class="code">java.util.Date</code> and
                <code class="code">java.util.Calendar</code>.</p><p><code class="code">XMLGregorianCalendar</code> supports the following
                XML schema calendar types: <code class="code">xs:date</code>,
                <code class="code">xs:time</code>, <code class="code">xs:dateTime</code>,
                <code class="code">xs:gYearMonth</code>, <code class="code">xs:gMonthDay</code>,
                <code class="code">xs:gYear</code>, <code class="code">xs:gMonth</code>, and
                <code class="code">xs:gDay</code>. It is statically mapped to
                <code class="code">xs:anySimpleType</code>, the common schema type from
                which all the XML schema calendar types are dervived. .NET
                maps <code class="code">xs:anySimpleType</code> to
                <code class="code">System.string</code>.</p><p><code class="code">java.util.Date</code> and
                <code class="code">java.util.Calendar</code> map to
                <code class="code">xs:dateTime</code>, but don&#8218;&Auml;&ouml;&#8730;&Ntilde;&#8730;&yen;t provide as complete
                XML support as <code class="code">XMLGregorianCalendar</code> does.</p><p><span class="emphasis"><em>Guideline:</em></span> Use the annotation
                <code class="code">@XmlSchemaType</code> for a strongly typed binding of
                <code class="code">XMLGregorianCalendar</code> to one of the XML schema
                calendar types.</p><div class="example"><a name="d0e14498"></a><p class="title"><b>Example&nbsp;16.9.&nbsp;<code class="code">XmlGregorianCalendar</code>
                    <span class="emphasis"><em>without</em></span>
                    <code class="code">@XmlSchemaType</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class PurchaseOrder {
    public javax.xml.datatype.XMLGregorianCalendar orderDate;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="orderDate" type="xs:anySimpleType" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
public partial class purchaseOrder
{
    private string orderDateField;
    public string orderDate
    {
        get { return this.orderDateField; }
        set { this.orderDateField = value; }
    }
}

//-- C# code fragment
purchaseOrder tmpP = new purchaseOrder();
tmpP.orderDate = System.Xml.XmlConvert.ToString(
   System.DateTime.Now, System.Xml.XmlDateTimeSerializerMode.RoundtripKind);</pre></div></div><br class="example-break"><div class="example"><a name="d0e14510"></a><p class="title"><b>Example&nbsp;16.10.&nbsp;<code class="code">XMLGregorianCalendar</code>
                    <span class="emphasis"><em>with</em></span>
                    <code class="code">@XmlSchemaType</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class PurchaseOrder {
    @XmlSchemaType(name="dateTime")
    public javax.xml.datatype.XMLGregorianCalendar orderDate;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="orderDate" type="xs:dateTime" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
public partial class purchaseOrder : object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
    private System.DateTime orderDateField;

    public System.Runtime.Serialization.ExtensionDataObject ExtensionData
    {
        get { return this.extensionDataField; }
        set { this.extensionDataField = value; }
    }

    public System.DateTime orderDate
    {
        get { return this.orderDateField; }
        set { this.orderDateField = value; }
    }
}

//-- C# code fragment
purchaseOrder tmpP = new purchaseOrder();
tmpP.orderDate = System.DateTime.Now;</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.7.&nbsp;UUID Type"><div class="titlepage"><div><div><h4 class="title"><a name="ahihg"></a>16.1.1.7.&nbsp;UUID Type</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> Use Leach-Salz variant
                of UUID at runtime.</p><p><code class="code">java.util.UUID</code> maps to schema type
                <code class="code">xs:string</code>. .NET maps <code class="code">xs:string</code> to
                <code class="code">System.string</code>. The constructors in
                <code class="code">java.util.UUID</code> allow any variant of UUID to be
                created. Its methods are for manipulation of the Leach-Salz
                variant.</p><div class="example"><a name="d0e14545"></a><p class="title"><b>Example&nbsp;16.11.&nbsp;Mapping <code class="code">UUID</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class ReportUid {
    public java.util.UUID uuid;
}

//-- Schema fragment
&lt;xs:complexType name="reportUid"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="uuid" type="xs:string" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
public partial class reportUid: object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
    private string uuidField;

    public System.Runtime.Serialization.ExtensionDataObject ExtensionData
    {
        get { return this.extensionDataField; }
        set { this.extensionDataField = value; }
    }

    public string uuid
    {
        get { return this.uuidField; }
        set { this.uuidField = value; }
    }
}

//-- C# code fragment
reportUid tmpU = new reportUid();
System.Guid guid = new System.Guid("06b7857a-05d8-4c14-b7fa-822e2aa6053f");
tmpU.uuid = guid.ToString();</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.8.&nbsp;Typed Variables"><div class="titlepage"><div><div><h4 class="title"><a name="ahihh"></a>16.1.1.8.&nbsp;Typed Variables</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> A typed variable maps to
                <code class="code">xs:anyType</code>. .NET maps <code class="code">xs:anyType</code> to
                <code class="code">System.Object</code>.</p><div class="example"><a name="d0e14568"></a><p class="title"><b>Example&nbsp;16.12.&nbsp;Using a typed variable</b></p><div class="example-contents"><pre class="programlisting">// Java class
public class Shape &lt;T&gt;
{
    private T xshape;

    public Shape() {};
    public Shape(T f)
    {
        xshape = f;
    }
}

//-- Schema fragment
&lt;xs:complexType name="shape"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="xshape" type="xs:anyType" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// C# code generated by svcutil
public partial class shape
{
    private object xshapeField;

    public object xshape
    {
        get { return this.xshapeField; }
        set { this.xshapeField = value; }
    }
}</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.9.&nbsp;Collections Types"><div class="titlepage"><div><div><h4 class="title"><a name="ahihi"></a>16.1.1.9.&nbsp;Collections Types</h4></div></div></div><p>Java collections types
                (<code class="code">java.util.Collection</code> and its subtypes, array,
                List, and parameterized collection types such as
                <code class="code">List&lt;Integer&gt;</code>) can be mapped to XML schema
                in different ways and can be serialized in different ways. The
                following examples show .NET bindings.</p><div class="section" title="16.1.1.9.1.&nbsp;List of Nillable Elements"><div class="titlepage"><div><div><h5 class="title"><a name="ahihj"></a>16.1.1.9.1.&nbsp;List of Nillable Elements</h5></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> By default, a
                    collection type such as <code class="code">List&lt;Integer&gt;</code>
                    maps to an XML schema construct that is a repeating
                    unbounded occurrence of an optional and nillable element.
                    .NET binds the XML schema construct to
                    <code class="code">System.Nullable&lt;int&gt;[]</code>. The element is
                    optional and nillable. However, when marshalling JAXB
                    marshaller will always marshal a null value using
                    <code class="code">xsi:nil</code>.</p><div class="example"><a name="d0e14600"></a><p class="title"><b>Example&nbsp;16.13.&nbsp;Collection to a list of nillable
                        elements</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
@XmlRootElement(name="po")
public PurchaseOrder {
    public List&lt;Integer&gt; items;
}

//-- Schema fragment
&lt;xs:element name="po" type="purchaseOrder"&gt;
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="items" type="xs:int" nillable="true"
                    minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
...

//--- JAXB XML serialization
&lt;po&gt;
    &lt;items&gt; 1 &lt;/items&gt;
    &lt;items&gt; 2 &lt;/items&gt;
    &lt;items&gt; 3 &lt;/items&gt;
&lt;/po&gt;

&lt;po&gt;
    &lt;items&gt; 1 &lt;/items&gt;
    &lt;items xsi:nil=true/&gt;
    &lt;items&gt; 3 &lt;/items&gt;
&lt;/po&gt;

//-- .NET auto generated code from schema
partial class purchaseOrder {
        private System.Nullable&lt;int&gt;[] itemsField;

    public System.Nullable&lt;int&gt;[] items
    {
        get { return this.itemsField; }
        set { this.itemsField = value; }
    }
}</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.9.2.&nbsp;List of Optional Elements"><div class="titlepage"><div><div><h5 class="title"><a name="ahihk"></a>16.1.1.9.2.&nbsp;List of Optional Elements</h5></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> This is the same as
                    above except that a collection type such as
                    <code class="code">List&lt;Integer&gt;</code> maps to a repeating
                    unbounded occurrence of an optional
                    (<code class="code">minOccurs="0"</code>) but not nillable element.
                    This in turn binds to .NET type <code class="code">int[]</code>. This
                    is more developer friendly. However, when marshalling,
                    JAXB will marshal a null value within the
                    <code class="code">List&lt;Integer&gt;</code> as a value that is absent
                    from the XML instance.</p><div class="example"><a name="d0e14624"></a><p class="title"><b>Example&nbsp;16.14.&nbsp;Collection to a list of optional
                        elements</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
@XmlRootElement(name="po")
public PurchaseOrder {
    @XmlElement(nillable=false)
    public List&lt;Integer&gt; items;
}

//-- Schema fragment
&lt;xs:element name="po" type="purchaseOrder"&gt;
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="items" type="xs:int"
                    minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
...

// .NET auto generated code from schema
partial class purchaseOrder {
    private int[] itemsField;

    public int[] items
    {
        get { return this.itemsField; }
        set { this.itemsField = value; }
    }
}</pre></div></div><br class="example-break"></div><div class="section" title="16.1.1.9.3.&nbsp;List of Values"><div class="titlepage"><div><div><h5 class="title"><a name="ahihl"></a>16.1.1.9.3.&nbsp;List of Values</h5></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> A collection such as
                    <code class="code">List&lt;Integer&gt;</code> can be mapped to a list
                    of XML values (that is, an XML schema list simple type)
                    using annotation <code class="code">@XmlList</code>. .NET maps a list
                    simple type to a .NET <code class="code">System.string</code>.</p><div class="example"><a name="d0e14645"></a><p class="title"><b>Example&nbsp;16.15.&nbsp;Collection to a list of values using
                        <code class="code">@XmlList</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
@XmlRootElement(name="po")
public PurchaseOrder {
    @XmlList public List&lt;Integer&gt; items;
}

//-- Schema fragment
&lt;xs:element name="po" type="purchaseOrder"&gt;
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:element name="items" minOccurs="0"&gt;
        &lt;xs:simpleType&gt;
            &lt;xs:list itemType="xs:int"/&gt;
        &lt;/xs:simpleType&gt;
    &lt;/xs:element&gt;
&lt;/xs:complexType&gt;
...

//-- XML serialization
&lt;po&gt;
    &lt;items&gt; 1 2 3 &lt;/items&gt;
&lt;/po&gt;

// .NET auto generated code from schema
partial class purchaseOrder {
    private string itemsField;

    public string items
    {
        get { return this.itemsField; }
        set { this.itemsField = value; }
    }
}</pre></div></div><br class="example-break"></div></div><div class="section" title="16.1.1.10.&nbsp;Array Types"><div class="titlepage"><div><div><h4 class="title"><a name="ahihm"></a>16.1.1.10.&nbsp;Array Types</h4></div></div></div><div class="example"><a name="d0e14655"></a><p class="title"><b>Example&nbsp;16.16.&nbsp;Single and multidimensional arrays</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class FamilyTree {
    public Person[] persons;
    public Person[][] family;
}

// .NET auto generated code from schema
public partial class familyTree
{
    private person[] persons;
    private person[][] families;

    public person[] persons
    {
        get { return this.membersField; }
        set { this.membersField = value; }
    }

    public person[][] families
    {
        get { return this.familiesField; }
        set { this.familiesField = value; }
    }
}</pre></div></div><br class="example-break"></div></div><div class="section" title="16.1.2.&nbsp;Fields and Properties"><div class="titlepage"><div><div><h3 class="title"><a name="ahihn"></a>16.1.2.&nbsp;Fields and Properties</h3></div></div></div><p>The following guidelines apply to mapping of JavaBeans
            properties and Java fields, but for brevity Java fields are
            used.</p><div class="section" title="16.1.2.1.&nbsp;@XmlElement Annotation"><div class="titlepage"><div><div><h4 class="title"><a name="ahiho"></a>16.1.2.1.&nbsp;@XmlElement Annotation</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> The
                <code class="code">@XmlElement</code> annotation maps a property or field
                to an XML element. This is also the default mapping in the
                absence of any other JAXB 2.0 annotations. The annotation
                parameters in <code class="code">@XmlElement</code> can be used to specify
                whether the element is optional or required, nillable or not.
                The following examples illustrate the corresponding bindings
                in the .NET client.</p><div class="example"><a name="d0e14678"></a><p class="title"><b>Example&nbsp;16.17.&nbsp;Map a field or property to a nillable
                    element</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class PurchaseOrder {

    // Map a field to a nillable XML element
    @javax.xml.bind.annotation.XmlElement(nillable=true)
    public java.math.BigDecimal price;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="price" type="xs:decimal"
                    nillable="true" minOccurs="0" /&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class purchaseOrder {
    private System.Nullable&lt;decimal&gt; priceField;
    private bool priceFieldSpecified;

    public decimal price
    {
        get { return this.priceField; }
        set { this.priceField = value; }
    }

    public bool priceSpecified {
    {
        get { return this.priceFieldSpecified; }
        set { this.priceFieldSpecified = value;}
    }
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e14683"></a><p class="title"><b>Example&nbsp;16.18.&nbsp;Map a property or field to a nillable, required
                    element</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class PurchaseOrder {

    // Map a field to a nillable XML element
    @XmlElement(nillable=true, required=true)
    public java.math.BigDecimal price;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="price" type="xs:decimal"
                    nillable="true" minOccurs="1" /&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class purchaseOrder {
    private System.Nullable&lt;decimal&gt; priceField;

    public decimal price
    {
        get { return this.priceField; }
        set { this.priceField = value; }
    }
}</pre></div></div><br class="example-break"></div><div class="section" title="16.1.2.2.&nbsp;@XmlAttribute Annotation"><div class="titlepage"><div><div><h4 class="title"><a name="ahihp"></a>16.1.2.2.&nbsp;@XmlAttribute Annotation</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> A property or field can
                be mapped to an XML attribute using <code class="code">@XmlAttribute</code>
                annotation. .NET binds an XML attribute to a property.</p><div class="example"><a name="d0e14698"></a><p class="title"><b>Example&nbsp;16.19.&nbsp;Mapping a field or property to an XML
                    attribute</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class UKAddress extends Address {
    @XmlAttribute
    public int exportCode;
}

//-- Schema fragment
&lt;! XML Schema fragment --&gt;
&lt;xs:complexType name="ukAddress"&gt;
    &lt;xs:complexContent&gt;
        &lt;xs:extension base="tns:address"&gt;
            &lt;xs:sequence/&gt;
            &lt;xs:attribute name="exportCode" type="xs:int"/&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class ukAddress : address
{
    private int exportCodeField;
    public int exportCode
    {
        get { return this.exportCodeField; }
        set { this.exportCodeField = value; }
    }
}</pre></div></div><br class="example-break"></div><div class="section" title="16.1.2.3.&nbsp;@XmlElementRefs Annotation"><div class="titlepage"><div><div><h4 class="title"><a name="ahihq"></a>16.1.2.3.&nbsp;@XmlElementRefs Annotation</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span>
                <code class="code">@XmlElementRefs</code> maps to a <code class="code">xs:choice</code>.
                This binds to a property with name <code class="code">item</code> in the C#
                class. If there is another field/property named
                <code class="code">item</code> in the Java class, there will be a name
                clash that .NET will resolve by generating name. To avoid the
                name clash, either change the name or use customization, for
                example <code class="code">@XmlElement(name="foo")</code>.</p><div class="example"><a name="d0e14725"></a><p class="title"><b>Example&nbsp;16.20.&nbsp;Mapping a field or property using
                    <code class="code">@XmlElementRefs</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class PurchaseOrder {
    @XmlElementRefs({
        @XmlElementRef(name="plane", type=PlaneType.class),
        @XmlElementRef(name="auto", type=AutoType.class)})
    public TransportType shipBy;
}

@XmlRootElement(name="plane")
public class PlaneType extends TransportType {}

@XmlRootElement(name="auto")
public class AutoType extends TransportType { }

@XmlRootElement
public class TransportType { ... }

//-- Schema fragment
&lt;!-- XML schema generated by wsgen --&gt;
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:choice&gt;
        &lt;xs:element ref="plane"/&gt;
        &lt;xs:element ref="auto"/&gt;
    &lt;/xs:choice&gt;
&lt;/xs:complexType&gt;

&lt;!-- XML global elements --&gt;
&lt;xs:element name="plane" type="autoType" /&gt;
&lt;xs:element name="auto" type="planeType" /&gt;

&lt;xs:complexType name="autoType"&gt;
    &lt;!-- content omitted - details not relevant to example --&gt;
&lt;/xs:complexType&gt;

&lt;/xs:complexType name="planeType"&gt;
    &lt;!-- content omitted - details not relevant to example --&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class purchaseOrder {
    private transportType itemField;

    [System.Xml.Serialization.XmlElementAttribute("auto", typeof(autoType), Order=4)]
    [System.Xml.Serialization.XmlElementAttribute("plane", typeof(planeType), Order=4)]
    public transportType Item
    {
        get { return this.itemField; }
        set { this.itemField = value; }
    }

public partial class planeType { ... } ;
public partial class autoType { ... } ;</pre></div></div><br class="example-break"></div></div><div class="section" title="16.1.3.&nbsp;Java Classes"><div class="titlepage"><div><div><h3 class="title"><a name="ahihr"></a>16.1.3.&nbsp;Java Classes</h3></div></div></div><p>A Java class can be mapped to different XML schema type
            and/or an XML element. The following guidelines apply to the usage
            of annotations at the class level.</p><div class="section" title="16.1.3.1.&nbsp;@XmlType Annotation - Anonymous Type"><div class="titlepage"><div><div><h4 class="title"><a name="ahihs"></a>16.1.3.1.&nbsp;@XmlType Annotation - Anonymous Type</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> Prefer mapping class to
                named XML schema type rather than an anonymous type for a
                better .NET type binding.</p><p>The <code class="code">@XmlType</code> annotation is used to
                customize the mapping of a Java class to an anonymous type.
                .NET binds an anonymous type to a .NET class - one per
                reference to the anonymous type. Thus, each Java class mapped
                to an anonymous type can generate multiple classes on the .NET
                client.</p><div class="example"><a name="d0e14749"></a><p class="title"><b>Example&nbsp;16.21.&nbsp;Mapping a Java class to an anonymous type using
                    <code class="code">@XmlType</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class PurchaseOrder {
    public java.util.List&lt;Item&gt; item;
}
@XmlType(name="")
public class Item {
    public String productName;
    ...
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="item"&gt;
            &lt;xs:complexType&gt;
                &lt;xs:sequence&gt;
                    &lt;xs:element name="productName" type="xs:string"/&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:complexType
&gt;        &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// C# code generated by svcutil
public partial class purchaseOrder
{
    private purchaseOrderItem[] itemField;
    System.Xml.Serialization.XmlElementAttribute("item",
        Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true, Order=0)]
    public purchaseOrderItem[] item
    {
        get {
            return this.itemField;
        }

        set {
            this.itemField = value;
        }
    }
}

// .NET auto generated code from schema
public partial class purchaseOrderItem
{
    private string productNameField;
    public string productName {
        get { return this.productNameField; }
        set { this.productNameField = value; }
    }
}</pre></div></div><br class="example-break"></div><div class="section" title="16.1.3.2.&nbsp;@XmlType Annotation - xs:all"><div class="titlepage"><div><div><h4 class="title"><a name="ahiht"></a>16.1.3.2.&nbsp;@XmlType Annotation - xs:all</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> Avoid using
                <code class="code">XmlType(propOrder=:{})</code>.</p><p><code class="code">@XmlType(propOrder={})</code> maps a Java class to
                an XML Schema complex type with <code class="code">xs:all</code> content
                model. Since XML Schema places severe restrictions on
                <code class="code">xs:all</code>, the use of
                <code class="code">@XmlType(propOrder={})</code> is therefore not
                recommended. So, the following example shows the mapping of a
                Java class to <code class="code">xs:all</code>, but the corresponding .NET
                code generated by <code class="code">svcutil</code> is omitted.</p><div class="example"><a name="d0e14785"></a><p class="title"><b>Example&nbsp;16.22.&nbsp;Mapping a class to <code class="code">xs:all</code> using
                    <code class="code">@XmlType</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
@XmlType(propOrder={})
public class USAddress {
    public String name;
    public String street;
}

//-- Schema fragment
&lt;xs:complexType name="USAddress"&gt;
    &lt;xs:all&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="street" type="xs:string"/&gt;
        ...
    &lt;/xs:all&gt;
&lt;/xs:complexType&gt;</pre></div></div><br class="example-break"></div><div class="section" title="16.1.3.3.&nbsp;@XmlType Annotation - Simple Content"><div class="titlepage"><div><div><h4 class="title"><a name="ahihu"></a>16.1.3.3.&nbsp;@XmlType Annotation - Simple Content</h4></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> A class can be mapped to
                a <code class="code">complexType</code> with a <code class="code">simpleContent</code>
                using <code class="code">@XmlValue</code> annotation. .NET binds the Java
                property annotated with <code class="code">@XmlValue</code> to a property
                with name <code class="code">"value"</code>.</p><div class="example"><a name="d0e14817"></a><p class="title"><b>Example&nbsp;16.23.&nbsp;Class to <code class="code">complexType</code> with
                    <code class="code">simpleContent</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public class InternationalPrice
{
    @XmlValue
    public java.math.BigDecimal price;

    @XmlAttribute public String currency;
}

//-- Schema fragment
&lt;xs:complexType name="internationalPrice"&gt;
    &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:decimal"&gt;
            xs:attribute name="currency" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
 &lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class internationalPrice
{
    private string currencyField;
    private decimal valueField;
    public string currency
    {
        get { return this.currencyField; }
        set { this.currencyField = value;}
    }

    public decimal Value
    {
        get { return this.valueField; }
        set { this.valueField = value;}
    }
}</pre></div></div><br class="example-break"></div></div><div class="section" title="16.1.4.&nbsp;Open Content"><div class="titlepage"><div><div><h3 class="title"><a name="ahihv"></a>16.1.4.&nbsp;Open Content</h3></div></div></div><p>JAXB 2.0 supports the following annotations for defining
            open content. (Open content allows content not statically defined
            in XML schema to occur in an XML instance):</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <code class="code">@XmlAnyElement</code> annotation maps to
                    <code class="code">xs:any</code>, which binds to the .NET type
                    <code class="code">System.Xml.XmlElement[]</code>.</p></li><li class="listitem"><p>The <code class="code">@XmlAnyAttribute</code> annotation maps to
                    <code class="code">xs:anyAttribute</code>, which binds to the .NET type
                    <code class="code">System.Xml.XmlAttribute[]</code>.</p></li></ul></div><div class="example"><a name="d0e14857"></a><p class="title"><b>Example&nbsp;16.24.&nbsp;Using <code class="code">@XmlAnyElement</code> for open
                content</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
@XmlType(propOrder={"name", "age", "oc"})
public class OcPerson {
    @XmlElement(required=true)
    public String name;
    public int age;

    // Define open content
    @XmlAnyElement
    public List&lt;Object&gt; oc;
}

//-- Schema fragment
&lt;xs:complexType name="ocPerson"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="age" type="xs:int"/&gt;
        &lt;xs:any minOccurs="0" maxOccurs="unbounded"&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public class ocPerson
{
    private String name;
    private int age;
    private System.Xml.XmlElement[] anyField;&lt;

    public String name { ... }
    public int age { ... }

    public System.Xml.XmlElement[] Any {
    {
        get { return this.anyField; }
        set { this.anyField = value; }
    }
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e14865"></a><p class="title"><b>Example&nbsp;16.25.&nbsp;Using <code class="code">@XmlAnyAttribute</code> for open
                content</b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
@XmlType(propOrder={"name", "age"}
public class OcPerson {
    public String name;
    public int age;

    // Define open content
    @XmlAnyAttribute
    public java.util.Map oc;
}

//-- Schema fragment
&lt;xs:complexType name="ocPerson"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="age" type="xs:int"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute/&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public class ocPerson
{
    private String name;
    private double age;
    private System.Xml.XmlAttribute[] anyAttrField;&lt;

    public String name { ... }
    public double age { ... }

    public System.Xml.XmlElement[] anyAttr {
    {
        get { return this.anyAttrField; }
        set { this.anyAttrField = value; }
    }
}</pre></div></div><br class="example-break"></div><div class="section" title="16.1.5.&nbsp;Enum Type"><div class="titlepage"><div><div><h3 class="title"><a name="ahihw"></a>16.1.5.&nbsp;Enum Type</h3></div></div></div><p><span class="emphasis"><em>Guideline:</em></span> A Java <code class="code">enum</code>
            type maps to an XML schema type constrained by enumeration facets.
            This, in turn, binds to the .NET type <code class="code">enum</code>
            type.</p><div class="example"><a name="d0e14886"></a><p class="title"><b>Example&nbsp;16.26.&nbsp;Java <code class="code">enum</code> &#8596; <code class="code">xs:simpleType</code>
                (with <code class="code">enum</code> facets) &#8596; .NET
                <code class="code">enum</code></b></p><div class="example-contents"><pre class="programlisting">//-- Java code fragment
public enum USState {MA, NH}

//-- Schema fragment
&lt;xs:simpleType name="usState"&gt;
    &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="NH" /&gt;
        &lt;xs:enumeration value="MA" /&gt;
    &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

// .NET auto generated code from schema
public enum usState { NH, MA }</pre></div></div><br class="example-break"></div><div class="section" title="16.1.6.&nbsp;Package-level Annotations"><div class="titlepage"><div><div><h3 class="title"><a name="ahihx"></a>16.1.6.&nbsp;Package-level Annotations</h3></div></div></div><p>The following package-level JAXB annotations are relevant
            from an interoperability standpoint:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">@XmlSchema</code> - customizes the mapping of
                    package to XML namespace.</p></li><li class="listitem"><p><code class="code">@XmlSchemaType</code> - customizes the mapping
                    of XML schema built-in type. The
                    <code class="code">@XmlSchemaType</code> annotation can also be used at
                    the property/field level, as was seen in the example <a class="xref" href="ch16.html#ahihf" title="16.1.1.6.&nbsp;XMLGregorianCalendar Type">XMLGregorianCalendar Type</a>.</p></li></ul></div><div class="section" title="16.1.6.1.&nbsp;@XmlSchema Annotation"><div class="titlepage"><div><div><h4 class="title"><a name="ahihy"></a>16.1.6.1.&nbsp;@XmlSchema Annotation</h4></div></div></div><p>A package is mapped to an XML namespace. The following
                attributes of the XML namespace can be customized using the
                <code class="code">@XmlSchema</code> annotation parameters:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">elementFormDefault</code> using
                        <code class="code">@XmlSchema.elementFormDefault()</code></p></li><li class="listitem"><p><code class="code">attributeFormDefault</code> using
                        <code class="code">@XmlSchema.attributeFormDefault()</code></p></li><li class="listitem"><p><code class="code">targetNamespace</code> using
                        <code class="code">@XmlSchema.namespace()</code></p></li><li class="listitem"><p>Associate namespace prefixes with the XML
                        namespaces using the <code class="code">@XmlSchema.ns()</code>
                        annotation</p></li></ul></div><p>These XML namespace attributes are bound to .NET
                serialization attributes (for example,
                <code class="code">XmlSerializer</code> attributes).</p></div><div class="section" title="16.1.6.2.&nbsp;Not Recommended Annotations"><div class="titlepage"><div><div><h4 class="title"><a name="ahihz"></a>16.1.6.2.&nbsp;Not Recommended Annotations</h4></div></div></div><p>Any JAXB 2.0 annotation can be used, but the following
                are not recommended:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The
                        <code class="code">javax.xml.bind.annotation.XmlElementDecl</code>
                        annotation is used to provide complete XML schema
                        support.</p></li><li class="listitem"><p>The <code class="code">@XmlID</code> and
                        <code class="code">@XmlIDREF</code> annotations are used for XML
                        object graph serialization, which is not well
                        supported.</p></li></ul></div></div></div></div><div class="section" title="16.2.&nbsp;Web Service - Start from WSDL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ahiia"></a>16.2.&nbsp;Web Service - Start from WSDL</h2></div></div></div><p>The following guidelines apply when designing a Java web service
        starting from a WSDL:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>If the WSDL was generated by
                <code class="code">DataContractSerializer</code>, enable JAXB 2.0
                customizations described in <a class="xref" href="ch16.html#ahiic" title="16.3.&nbsp;Customizations for WCF Service WSDL">Customizations for WCF Service WSDL</a>. The rationale for the JAXB 2.0
                customizations is described in the same section.</p></li><li class="listitem"><p>If the WSDL is a result of contract first approach,
                verify that the WSDL can be processed by either the
                <code class="code">DataContractSerializer</code> or
                <code class="code">XmlSerializer</code> mechanisms.</p><p>The purpose of this step is to ensure that the WSDL uses
                only the set of XML schema features supported by JAXB 2.0 or
                .NET serialization mechanisms. JAXB 2.0 was designed to
                support all the XML schema features. The WCF serialization
                mechanisms, <code class="code">DataContractSerializer</code> and
                <code class="code">XmlSerializer</code>, provide different levels of
                support for XML schema features. Thus, the following step will
                ensure that the WSDL/schema file can be consumed by the WCF
                serialization mechanisms.</p><pre class="programlisting"><span class="bold"><strong>svcutil <span class="emphasis"><em>wsdl-file</em></span></strong></span></pre><p>The <code class="code">svcutil.exe</code> tool, by default, uses
                <code class="code">DataContractSerializer</code> but falls back to
                <code class="code">XmlSerializer</code> if it encounters an XML schema
                construct not supported by <code class="code">XmlFormatter</code>.</p></li></ol></div></div><div class="section" title="16.3.&nbsp;Customizations for WCF Service WSDL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ahiic"></a>16.3.&nbsp;Customizations for WCF Service WSDL</h2></div></div></div><p>When developing either a Java web service or a Java client from
        a WCF service WSDL generated using
        <code class="code">DataContractSerializer</code>, the following JAXB 2.0
        customizations are useful and/or required.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">generateElementProperty</code> attribute</p></li><li class="listitem"><p><code class="code">mapSimpleTypeDef</code> attribute</p></li></ul></div><p>The following sections explain the use and rationale of these
        customizations.</p><div class="section" title="16.3.1.&nbsp;generateElementProperty Attribute"><div class="titlepage"><div><div><h3 class="title"><a name="ahiid"></a>16.3.1.&nbsp;generateElementProperty Attribute</h3></div></div></div><p>WCF service WSDL generated from a programming language such
            as C# using <code class="code">DataContractSerializer</code> may contain XML
            Schema constructs which result in
            <code class="code">JAXBElement&lt;T&gt;</code> in generated code. A
            <code class="code">JAXBElement&lt;T&gt;</code> type can also sometimes be
            generated when a WSDL contains advanced XML schema features such
            as substitution groups or elements that are both optional and
            nillable. In all such cases, <code class="code">JAXBElement&lt;T&gt;</code>
            provides roundtripping support of values in XML instances.
            However, <code class="code">JAXBElement&lt;T&gt;</code> is not natural to a
            Java developer. So the <code class="code">generateElementProperty</code>
            customization can be used to generate an alternate developer
            friendly but lossy binding. The different bindings along with the
            trade-offs are discussed below.</p><div class="section" title="16.3.1.1.&nbsp;Default Binding"><div class="titlepage"><div><div><h4 class="title"><a name="ahiie"></a>16.3.1.1.&nbsp;Default Binding</h4></div></div></div><p>The following is the default binding of an optional
                <code class="code">(minOccurs="0")</code> and
                <code class="code">nillable(nillable="true")</code> element:</p><div class="example"><a name="d0e15090"></a><p class="title"><b>Example&nbsp;16.27.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- XML schema fragment --&gt;
&lt;xs:element name="person" type="Person"/&gt;
&lt;xs:complexType name="Person"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"
                    nillable="true" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
...</pre></div></div><br class="example-break"><div class="example"><a name="d0e15093"></a><p class="title"><b>Example&nbsp;16.28.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">// Binding
public class Person {
    JAXBElement&lt;String&gt; getName() {...};
    public void setName(JAXBElement&lt;String&gt; value) {...}
}</pre></div></div><br class="example-break"><p>Since the XML element <code class="code">name</code> is both optional
                and nillable, it can be represented in an XML instance in one
                of following ways:</p><div class="example"><a name="d0e15101"></a><p class="title"><b>Example&nbsp;16.29.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- Absence of element name--&gt;
&lt;person&gt;
    &lt;-- element name is absent --&gt;
&lt;/person&gt;

&lt;!-- Presence of an element name --&gt;
&lt;person&gt;
    &lt;name xsi:nil="true"/&gt;
&lt;/person&gt;</pre></div></div><br class="example-break"><p>The <code class="code">JAXBElement&lt;String&gt;</code> type
                roundtrips the XML representation of <code class="code">name</code> element
                across an unmarshal/marshal operation.</p></div><div class="section" title="16.3.1.2.&nbsp;Customized Binding"><div class="titlepage"><div><div><h4 class="title"><a name="ahiif"></a>16.3.1.2.&nbsp;Customized Binding</h4></div></div></div><p>When <code class="code">generateElementProperty</code> is false, the
                binding is changed as follows:</p><div class="example"><a name="d0e15120"></a><p class="title"><b>Example&nbsp;16.30.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">// set JAXB customization generateElementProperty="false"
public class Person {
    String getName() {...}
    public void setName(String value) {...}
}</pre></div></div><br class="example-break"><p>The above binding is more natural to Java developer than
                <code class="code">JAXBElement&lt;String&gt;</code>. However, it does not
                roundtrip the value of <code class="code">name</code>.</p><p>JAXB 2.0 allows <code class="code">generateElementProperty</code> to
                be set:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Globally in
                        <code class="code">&lt;jaxb:globalBindings&gt;</code></p></li><li class="listitem"><p>Locally in <code class="code">&lt;jaxb:property&gt;</code>
                        customization</p></li></ul></div><p>When processing a WCF service WSDL, it is recommended
                that the <code class="code">generateElementProperty</code> customization be
                set in <code class="code">&lt;jaxb:globalBindings&gt;</code>:</p><div class="example"><a name="d0e15156"></a><p class="title"><b>Example&nbsp;16.31.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;jaxb:bindings version="2.0"
               xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;jaxb:bindings schemaLocation="schema-importedby-wcfsvcwsdl"
                   node="/xs:schema"&gt;
        &lt;jaxb:globalBindings generateElementProperty="false"/&gt;
    &lt;/jaxb:bindings&gt;
    ...</pre></div></div><br class="example-break"><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="code">generateElementProperty</code> attribute
                    was introduced in JAXB 2.1.</p></div></div><div class="section" title="16.3.1.3.&nbsp;mapSimpleTypeDef Attribute"><div class="titlepage"><div><div><h4 class="title"><a name="ahiig"></a>16.3.1.3.&nbsp;mapSimpleTypeDef Attribute</h4></div></div></div><p>XML Schema Part 2: Datatype defines facilities for
                defining datatypes for use in XML Schemas. .NET platform
                introduced the CLR types for some of the XML schema datatypes
                as described in <a class="xref" href="ch16.html#ahiih" title="Table&nbsp;16.1.&nbsp;CLR to XML Schema Type Mapping">CLR to XML Schema Type Mapping</a>.</p><div class="table"><a name="ahiih"></a><p class="title"><b>Table&nbsp;16.1.&nbsp;CLR to XML Schema Type Mapping</b></p><div class="table-contents"><table summary="CLR to XML Schema Type Mapping" border="1"><colgroup><col><col></colgroup><thead><tr><th><p>CLR Type</p></th><th><p>XML Schema Type</p></th></tr></thead><tbody><tr><td><p> <code class="code">byte</code> </p></td><td><p> <code class="code">xs:unsignedByte</code>
                                </p></td></tr><tr><td><p> <code class="code">uint</code> </p></td><td><p> <code class="code">xs:unsignedInt</code>
                                </p></td></tr><tr><td><p> <code class="code">ushort</code> </p></td><td><p> <code class="code">xs:unsignedShor</code>
                                </p></td></tr><tr><td><p> <code class="code">ulong</code> </p></td><td><p> <code class="code">xs:unsignedLong</code>
                                </p></td></tr></tbody></table></div></div><br class="table-break"><p>However, there are no corresponding Java types that map
                to the XML Schema types listed in <a class="xref" href="ch16.html#ahiih" title="Table&nbsp;16.1.&nbsp;CLR to XML Schema Type Mapping">CLR to XML Schema Type Mapping</a>. Furthermore, JAXB 2.0 maps these
                XML schema types to Java types that are natural to Java
                developer. However, this results in a mapping that is not
                one-to-one. For example:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">xs:int -&gt; int</code></p></li><li class="listitem"><p><code class="code">xs:unsignedShort -&gt; int</code></p></li></ul></div><p>The lack of a one-to-one mapping means that when XML
                Schema types shown in <a class="xref" href="ch16.html#ahiih" title="Table&nbsp;16.1.&nbsp;CLR to XML Schema Type Mapping">CLR to XML Schema Type Mapping</a> are used in an
                <code class="code">xsi:type</code> construct, they won&#8218;&Auml;&ouml;&#8730;&Ntilde;&#8730;&yen;t be preserved
                by default across an unmarshal followed by marshal operation.
                For example:</p><div class="example"><a name="d0e15257"></a><p class="title"><b>Example&nbsp;16.32.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">// C# web method
public Object retObject(Object objvalue);
// Java web method generated from WCF service WSDL
public Object retObject(
    Object objvalue);
}</pre></div></div><br class="example-break"><p>The following illustrates why <code class="code">xsi:type</code> is
                not preserved across an unmarshal/marshal operation.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A value of type <code class="code">uint</code> is marshalled
                        by WCF serialization mechanism as:</p><div class="example"><a name="d0e15272"></a><p class="title"><b>Example&nbsp;16.33.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;objvalue xsi:type="xs:unsignedShort"/&gt;</pre></div></div><br class="example-break"></li><li class="listitem"><p>JAXB 2.0 unmarshaller unmarshals the value as an
                        instance of <code class="code">int</code> and assigns it to
                        parameter <code class="code">objvalue</code>.</p></li><li class="listitem"><p>The <code class="code">objvalue</code> is marshalled back by
                        JAXB 2.0 marshaller with an <code class="code">xsi:type</code> of
                        <code class="code">xs:int</code>.</p><div class="example"><a name="d0e15296"></a><p class="title"><b>Example&nbsp;16.34.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;objvalue xsi:type="xs:int"/&gt;</pre></div></div><br class="example-break"></li></ul></div><p>One way to preserve and roundtrip the
                <code class="code">xsi:type</code> is to use the
                <code class="code">mapSimpleTypeDef</code> customization. The customization
                makes the mapping of XML Schema Part 2 datatypes one--to-one
                by generating additional Java classes. Thus,
                <code class="code">xs:unsignedShort</code> will be bound to its own class
                rather than <code class="code">int</code>, as shown:</p><div class="example"><a name="d0e15313"></a><p class="title"><b>Example&nbsp;16.35.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">//Java class to which xs:unsignedShort is bound
public class UnsignedShort { ... }</pre></div></div><br class="example-break"><p>The following illustrates how the <code class="code">xsi:type</code>
                is preserved across an unmarshal/marshal operation:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A value of type <code class="code">uint</code> is marshalled
                        by WCF serialization mechanism as:</p><div class="example"><a name="d0e15328"></a><p class="title"><b>Example&nbsp;16.36.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;objvalue xsi:type="xs:unsignedShort"/&gt;</pre></div></div><br class="example-break"></li><li class="listitem"><p>JAXB 2.0 unmarshaller unmarshals the value as an
                        instance of <code class="code">UnsignedShort</code> and assigns it
                        to parameter <code class="code">objvalue</code>.</p></li><li class="listitem"><p>The <code class="code">objvalue</code> is marshalled back by
                        JAXB 2.0 marshaller with an <code class="code">xsi:type</code> of
                        <code class="code">xs:int</code>.</p><div class="example"><a name="d0e15352"></a><p class="title"><b>Example&nbsp;16.37.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;objvalue xsi:type="xs:unsignedShort"/&gt;</pre></div></div><br class="example-break"></li></ul></div><p><span class="emphasis"><em>Guideline:</em></span> Use the
                <code class="code">mapSimpleTypedef</code> customization where
                roundtripping of XML Schema types in <a class="xref" href="ch16.html#ahiih" title="Table&nbsp;16.1.&nbsp;CLR to XML Schema Type Mapping">CLR to XML Schema Type Mapping</a> are used in <code class="code">xsi:type</code>.
                However, it is preferable to avoid the use of CLR types listed
                in <a class="xref" href="ch16.html#ahiih" title="Table&nbsp;16.1.&nbsp;CLR to XML Schema Type Mapping">CLR to XML Schema Type Mapping</a> since
                they are specific to .NET platform.</p><p>The syntax of the <code class="code">mapSimpleTypeDef</code>
                customization is shown below.</p><div class="example"><a name="d0e15374"></a><p class="title"><b>Example&nbsp;16.38.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;jaxb:bindings version="2.0"
               xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;jaxb:bindings schemaLocation="schema-importedby-wcfsvcwsdl"&gt;
        &lt;jaxb:globalBindings mapSimpleTypeDef="true"/&gt;
    &lt;/jaxb:bindings&gt;
    ....</pre></div></div><br class="example-break"></div></div></div><div class="section" title="16.4.&nbsp;Developing a Microsoft .NET Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ahiii"></a>16.4.&nbsp;Developing a Microsoft .NET Client</h2></div></div></div><p>This section describes how to develop a .NET client that uses
        data binding.</p><div class="task" title="To Develop a Microsoft .NET Client"><a name="gfrep"></a><p class="title"><b>To Develop a Microsoft .NET Client</b></p><div class="tasksummary">
                <p>Perform the following steps to generate a Microsoft .NET
                client from a Java web service WSDL file.</p>
            </div><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1"><p><span class="bold"><strong>Generate WCF web service
                    client artifacts using the <code class="code">svcutil.exe</code>
                    tool:</strong></span></p><pre class="programlisting"><span class="bold"><strong>svcutil.exe <span class="emphasis"><em>java-web-service-wsdl</em></span></strong></span></pre><p><code class="code">svcutil.exe</code> has the following options
                    for selecting a serializer:</p><ul class="stepalternatives">
                        <li class="step" title="Step 1.1"><p><code class="code">svcutil.exe /serializer:auto</code>
                            (default)</p></li>

                        <li class="step" title="Step 1.2"><p><code class="code">svcutil.exe
                            /serializer:DataContractSerializer</code></p></li>

                        <li class="step" title="Step 1.3"><p><code class="code">svcutil.exe
                            /serializer:XmlSerializer</code></p></li>
                    </ul><p>It is recommended that you use the default option,
                    <code class="code">/serializer:auto</code>. This option ensures that
                    <code class="code">svcutil.exe</code> falls back to
                    <code class="code">XmlSerializer</code> if an XML schema construct is
                    used that cannot be processed by
                    <code class="code">DataContractSerializer</code>.</p><p>For example, in the following class the field
                    <code class="code">price</code> is mapped to an XML attribute that
                    cannot be consumed by
                    <code class="code">DataContractSerializer</code>.</p><div class="example"><a name="d0e15450"></a><p class="title"><b>Example&nbsp;16.39.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">public class POType {
    @javax.xml.bind.annotation.XmlAttribute
    public java.math.BigDecimal price;
}

&lt;!-- XML schema fragment --&gt;
&lt;xs:complexType name="poType"&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute name="price" type="xs:decimal"/&gt;
&lt;/xs:complexType&gt;</pre></div></div><br class="example-break"></li><li class="step" title="Step 2"><p><span class="bold"><strong>Develop the .NET client using
                    the generated artifacts.</strong></span></p></li></ol></div></div></div><div class="section" title="16.5.&nbsp;BP 1.1 Conformance"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ahiij"></a>16.5.&nbsp;BP 1.1 Conformance</h2></div></div></div><p>JAX-WS 2.0 enforces strict Basic Profile 1.1 compliance. In one
        situation, the .NET framework does not enforce strict BP 1.1
        semantics, and their usage can lead to interoperability
        problems.</p><p>In <code class="code">rpclit</code> mode, <a class="link" href="http://www.ws-i.org/Profiles/BasicProfile-1.1-2006-04-10.html" target="_top">BP
        1.1</a>, R2211 disallows the use of <code class="code">xsi:nil</code> in part
        accessors: An <span class="emphasis"><em>ENVELOPE</em></span> described with an
        <code class="code">rpc-literal</code> binding <span class="emphasis"><em>MUST NOT</em></span> have
        the <code class="code">xsi:nil</code> attribute with a value of <code class="code">"1"</code> or
        <code class="code">"true"</code> on the part accessors.</p><p>From a developer perspective this means that in
        <code class="code">rpclit</code> mode, JAX-WS does not allow a null to be passed in
        a web service method parameter.</p><div class="example"><a name="d0e15497"></a><p class="title"><b>Example&nbsp;16.40.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">//Java Web method
public byte[] retByteArray(byte[] inByteArray) {
    return inByteArray;
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e15500"></a><p class="title"><b>Example&nbsp;16.41.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- In rpclit mode, the above Java web service method will throw an exception
  if the following XML instance with xsi:nil is passed by a .NET client.--&gt;
  &lt;RetByteArray xmlns="http://tempuri.org/"&gt;
      &lt;inByteArray a:nil="true" xmlns=""
          xmlns:a="http://www.w3.org/2001/XMLSchema-instance"/&gt;
  &lt;/RetByteArray&gt;</pre></div></div><br class="example-break"></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch15.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch17.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;15.&nbsp;Accessing Metro Services Using WCF Clients&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;17.&nbsp;Modular Databinding</td></tr></table></div></body></html>